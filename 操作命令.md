# 操作命令

## 帮助命令

```
[root@hadoop101 atguigu]# docker --help
[root@hadoop101 atguigu]# docker info
[root@hadoop101 atguigu]# docker version
```

## 镜像命令 

列出本地主机的镜像

```
[root@hadoop101 atguigu]# docker images
options说明：
-a 列出本地所有镜像(含中间映像层)
-q 只显示镜像ID
--digests 显示镜像的摘要信息
--no-trunc 显示完整的镜像信息
```

在dockerHub(http://hub.docker.com)上查找某个镜像名字

```
docker search 某个xx镜像的名字
options说明:
--no-trunc 显示完整的镜像描述
-s 列出收藏数不小于指定值的镜像
--automated 只列出atuomated build类型的镜像
```

下载镜像

```
docker pull 某个镜像的名字
[root@hadoop101 atguigu]# docker pull tomcat
```

删除镜像

```
删除单个：docker rmi -f 某个镜像名字
删除多个：docker rmi -f 某个镜像名字1 某个镜像名字2
删除全部：docker rmi -f $(docker images -qa)
```

## 容器命令

新建并启动容器

```
docker run [options] images的名字 [command]
OPTIONS说明（常用）：有些是一个减号，有些是两个减号

 

--name="容器新名字": 为容器指定一个名称；

-d: 后台运行容器，并返回容器ID，也即启动守护式容器；

-i：以交互模式运行容器，通常与 -t 同时使用；

-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；

-P: 随机端口映射；

-p: 指定端口映射，有以下四种格式

      ip:hostPort:containerPort

      ip::containerPort

      hostPort:containerPort

      containerPort
#使用镜像centos:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。
docker run -it centos:6.10 /bin/bash 

```

列出当前所有正在运行的docker进程

```
docker ps [options]
OPTIONS说明（常用）：
-a :列出当前所有正在运行的容器+历史上运行过的

-l :显示最近创建的容器。

-n：显示最近n个创建的容器。

-q :静默模式，只显示容器编号。

--no-trunc :不截断输出。

```

退出容器

​	方式一 容器停止退出

```
exit
```

​	 方式二  容器不停止退出

```
ctrl+P+Q
```

启动容器

```
docker start 容器ID或者容器名
```

重启容器

```
docker restart 容器名或者容器ID
```

停止容器

```
docker stop 容器ID或者容器名
```

重新进入容器

```
docker exec -it 容器名  /bin/bash
```

强制停止容器

```
docker kill 容器ID或者容器名
```

删除已经停止的容器

```
docker rm 容器ID
docker rm -f $(docker ps -a -q)
docker ps -a -q|xages docker rm
```

## 重点

​		启动守护进程

```
#使用镜像centos:latest以后台模式启动一个容器

docker run -d centos

问题：然后docker ps -a 进行查看, 会发现容器已经退出

很重要的要说明的一点: Docker容器后台运行,就必须有一个前台进程.

容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。

这个是docker的机制问题,比如你的web容器,我们以nginx为例，正常情况下,我们配置启动服务只需要启动响应的service即可。例如

service nginx start

但是,这样做,nginx为后台进程模式运行,就导致docker前台没有运行的应用,

这样的容器后台启动后,会立即自杀因为他觉得他没事可做了.

所以，最佳的解决方案是,将你要运行的程序以前台进程的形式运行

```

​		产看容器日志

```
[root@hadoop101 atguigu]#  docker run -d centos:6.10 /bin/sh -c "while true;do echo hello zzyy;sleep 2;done"


docker logs -f -t --tail 容器ID
-t: 加入时间戳
-f: 跟随最新日志打印
--tail: 显示最后多少条
```

​		查看容器内运行的进程

```
docker top 容器ID
```

​		产看容器内部细节

```
docker inspect 容器ID
```

​		进入正在运行的容器并以命令行进行交互

```
方式一
docker exec -it 容器ID /bin/bash
方式二
docker attach 容器ID
区别:
attach 直接进入容器启动命令终端，不会启动新的进程
exec 是在容器中打开新的终端，并且可以启动的新的进程
如：
[root@hadoop101 atguigu]# docker exec -t 374eb7369f66 ls /tmp
	anaconda-post.log  yum.log

```

​		从容器内拷贝文件到主机上

```
docker cp 容器ID:容器内路径 目的主机的路径
```

## Docker镜像commit操作案例

```
1 从hub上下载tomcat镜像到本地并且成功运行
docker run -it -p 8888:8080 tomcat
-p 主机端口：docker容器端口
-P 随机分配端口
-i 交互
-t 终端
```

```
2 故意删除上一步镜像生产的镜像生产tomcat容器的文档
```

```
3 也即当前的tomcat运行实例是一个没有文档的容器，
以它为模板commit一个没有doc的tomcat新镜像yk/tomcat:1.1
[root@hadoop101 atguigu]# docker commit -a="yk" -m="tomcat without docs" 404582abfcd7 yk/tomcat:1.1
```

```
4启动我们的镜像和原来对比新启动的yk/tomcat:1.1打不开documention，也就是他没有docs。重新pull一个tomcat启动，它是有docs文件也就是能打开documention
```
